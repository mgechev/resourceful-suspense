{
  "version": 3,
  "sources": ["../../../../../../node_modules/@ngx-templates/shared/fesm2022/ngx-templates-shared-fetch.mjs"],
  "sourcesContent": ["import { InjectionToken, Injector } from '@angular/core';\nconst FETCH_API = new InjectionToken('FETCH_API');\n/**\n * Provide Fetch API.\n *\n * @param customImpl Use in case you want to provide your own implementation (e.g. a mock).\n * @returns Fetch `Provider`\n */\nconst provideFetchApi = customImpl => ({\n  provide: FETCH_API,\n  // We need to bind the native fetch to globalThis since we are in SSR mode\n  // or it will throw an \"Illegal invocation\"\n  useFactory: injector => customImpl ? customImpl(injector) : fetch.bind(globalThis),\n  deps: [Injector]\n});\n\n/**\n * Keeps track of abort controllers for running requests.\n * Use in API services.\n *\n * @returns Abort function that returns an AbortSignal\n */\nfunction fetchAbort() {\n  const abortCtrls = new Map();\n  return apiName => {\n    let ctrl = abortCtrls.get(apiName);\n    if (ctrl) {\n      ctrl.abort();\n    }\n    ctrl = new AbortController();\n    abortCtrls.set(apiName, ctrl);\n    return ctrl.signal;\n  };\n}\n\n// Represents a Fetch API mock created\n// purely for demo purposes.\n// A delayed promise response\nfunction simulateRequest(jsonDataFn, config, log, abortSignal) {\n  let timeout;\n  let reject = () => {};\n  let completed = false;\n  let abort = false;\n  // Abort the request if a signal is provided\n  abortSignal?.addEventListener('abort', () => {\n    if (!completed) {\n      log('Request aborted');\n      abort = true;\n      clearTimeout(timeout);\n      reject({\n        ok: false\n      });\n    }\n  });\n  return new Promise((res, rej) => {\n    reject = rej;\n    timeout = setTimeout(() => {\n      // Asynchronous mock request handlers are non-cancellable.\n      // They can still be aborted but any changes that they perform on the mock state\n      // (e.g. mock POST requests), if any, are irreversible. This is due to the nature\n      // of Promises.\n      Promise.resolve(jsonDataFn()).then(resolvedJsonData => {\n        // For Fetch mock async responses, we need to check\n        // whether the request has been cancelled upon Promise\n        // resolution.\n        if (abort) {\n          return;\n        }\n        log('Responding with data', resolvedJsonData || '<<EMPTY>>');\n        completed = true;\n        res({\n          ok: true,\n          json: () => Promise.resolve(resolvedJsonData)\n        });\n      });\n    }, config.responseDelay);\n  });\n}\nconst DEFAULT_CFG = {\n  responseDelay: 200,\n  logging: true\n};\n/**\n * Fetch API Mock\n *\n * **Limitation:** _Asynchronous mock request handlers are non-cancellable.\n * They can still be aborted but any changes that they perform on the mock state\n * (e.g. mock POST requests), if any, are irreversible. This is due to the nature\n * of Promises._\n *\n * @param url\n * @param init\n * @returns\n */\nconst withFetchMock = (mockFn, config) => {\n  const fullCfg = {\n    ...DEFAULT_CFG,\n    ...config\n  };\n  // Used for logging the operation in the console\n  const log = (msg, obj) => {\n    if (fullCfg?.logging) {\n      const prefix = msg[0] !== '*';\n      msg = prefix ? msg : msg.slice(1);\n      console.info(prefix ? 'Fetch API Mock:' : '', msg.trim(), obj || '');\n    }\n  };\n  return injector => (url, options) => {\n    const method = options?.method || 'GET';\n    log('*'); // Add some spacing in the console\n    log(`Executing request ${method} ${url}`);\n    const body = options?.body ? JSON.parse(options.body) : null;\n    if (body) {\n      log('Body', body);\n    }\n    return simulateRequest(() => mockFn(url.toString(), method, body, injector), fullCfg, log, options?.signal);\n  };\n};\nconst FETCH_MOCK_STATE = new InjectionToken('FETCH_MOCK_STATE');\n/**\n * Provide, if your Fetch API mock is stateful and uses `FETCH_MOCK_STATE`.\n */\nconst provideFetchMockState = () => ({\n  provide: FETCH_MOCK_STATE,\n  useValue: {\n    state: null\n  }\n});\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FETCH_API, FETCH_MOCK_STATE, fetchAbort, provideFetchApi, provideFetchMockState, withFetchMock };\n"],
  "mappings": ";;;;;;;;;AACA,IAAM,YAAY,IAAI,eAAe,WAAW;AAOhD,IAAM,kBAAkB,iBAAe;AAAA,EACrC,SAAS;AAAA;AAAA;AAAA,EAGT,YAAY,cAAY,aAAa,WAAW,QAAQ,IAAI,MAAM,KAAK,UAAU;AAAA,EACjF,MAAM,CAAC,QAAQ;AACjB;AAQA,SAAS,aAAa;AACpB,QAAM,aAAa,oBAAI,IAAI;AAC3B,SAAO,aAAW;AAChB,QAAI,OAAO,WAAW,IAAI,OAAO;AACjC,QAAI,MAAM;AACR,WAAK,MAAM;AAAA,IACb;AACA,WAAO,IAAI,gBAAgB;AAC3B,eAAW,IAAI,SAAS,IAAI;AAC5B,WAAO,KAAK;AAAA,EACd;AACF;AAKA,SAAS,gBAAgB,YAAY,QAAQ,KAAK,aAAa;AAC7D,MAAI;AACJ,MAAI,SAAS,MAAM;AAAA,EAAC;AACpB,MAAI,YAAY;AAChB,MAAI,QAAQ;AAEZ,eAAa,iBAAiB,SAAS,MAAM;AAC3C,QAAI,CAAC,WAAW;AACd,UAAI,iBAAiB;AACrB,cAAQ;AACR,mBAAa,OAAO;AACpB,aAAO;AAAA,QACL,IAAI;AAAA,MACN,CAAC;AAAA,IACH;AAAA,EACF,CAAC;AACD,SAAO,IAAI,QAAQ,CAAC,KAAK,QAAQ;AAC/B,aAAS;AACT,cAAU,WAAW,MAAM;AAKzB,cAAQ,QAAQ,WAAW,CAAC,EAAE,KAAK,sBAAoB;AAIrD,YAAI,OAAO;AACT;AAAA,QACF;AACA,YAAI,wBAAwB,oBAAoB,WAAW;AAC3D,oBAAY;AACZ,YAAI;AAAA,UACF,IAAI;AAAA,UACJ,MAAM,MAAM,QAAQ,QAAQ,gBAAgB;AAAA,QAC9C,CAAC;AAAA,MACH,CAAC;AAAA,IACH,GAAG,OAAO,aAAa;AAAA,EACzB,CAAC;AACH;AACA,IAAM,cAAc;AAAA,EAClB,eAAe;AAAA,EACf,SAAS;AACX;AAaA,IAAM,gBAAgB,CAAC,QAAQ,WAAW;AACxC,QAAM,UAAU,kCACX,cACA;AAGL,QAAM,MAAM,CAAC,KAAK,QAAQ;AACxB,QAAI,SAAS,SAAS;AACpB,YAAM,SAAS,IAAI,CAAC,MAAM;AAC1B,YAAM,SAAS,MAAM,IAAI,MAAM,CAAC;AAChC,cAAQ,KAAK,SAAS,oBAAoB,IAAI,IAAI,KAAK,GAAG,OAAO,EAAE;AAAA,IACrE;AAAA,EACF;AACA,SAAO,cAAY,CAAC,KAAK,YAAY;AACnC,UAAM,SAAS,SAAS,UAAU;AAClC,QAAI,GAAG;AACP,QAAI,qBAAqB,MAAM,IAAI,GAAG,EAAE;AACxC,UAAM,OAAO,SAAS,OAAO,KAAK,MAAM,QAAQ,IAAI,IAAI;AACxD,QAAI,MAAM;AACR,UAAI,QAAQ,IAAI;AAAA,IAClB;AACA,WAAO,gBAAgB,MAAM,OAAO,IAAI,SAAS,GAAG,QAAQ,MAAM,QAAQ,GAAG,SAAS,KAAK,SAAS,MAAM;AAAA,EAC5G;AACF;AACA,IAAM,mBAAmB,IAAI,eAAe,kBAAkB;AAI9D,IAAM,wBAAwB,OAAO;AAAA,EACnC,SAAS;AAAA,EACT,UAAU;AAAA,IACR,OAAO;AAAA,EACT;AACF;",
  "names": []
}
